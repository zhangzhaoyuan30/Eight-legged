# 并发
1. Reentranlock怎么实现？

    - Sync:

        - nonfairTryAcquire

            如果stat=0，cas操作设置stat为1，设置持锁线程
        
            否则，如果重入则加1

        - tryRelease

            先判断是否是持锁线程，然后设置stat为getStat-1

    - NonfairSync:

        - tryAcquire调用nonfairTryAcquire
    - FairSync:

        - tryAcquire
        
            如果stat=0，**先判断队列中是否有其他线程等待**，如果没有cas操作设置stat为1，设置持锁线程
        
            否则，如果重入则加1


2. AQS原理？

    - acquire:

        ```
        public final void acquire(int arg) {
            //获取stat
            if (!tryAcquire(arg) &&
                //不成功则加入队列尾部
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
        }
        ```
        acquireQueued()中循环判断前驱是否头结点：
        
        - 是，tryAcquire，成功后当前节点设为头结点
        
        - 否，进入等待
    - release：
        ```
        public final boolean release(int arg) {
            if (tryRelease(arg)) {
                Node h = head;
                if (h != null && h.waitStatus != 0)
                    unparkSuccessor(h);
                return true;
            }
            return false;
        }
        ```
      unparkSuccessor()的作用是**唤醒当前线程的后继线程**

3. ReentrantLock优势？

4. ConcurrentHashMap原理？

5. UML图
