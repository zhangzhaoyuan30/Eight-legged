<!-- TOC -->

- [1 常见的限流方法](#1-常见的限流方法)
- [2 优缺点](#2-优缺点)
- [3 代码](#3-代码)
- [4 分布式限流](#4-分布式限流)

<!-- /TOC -->
# 1 常见的限流方法
- 固定窗口计数器：按照时间段划分窗口，有一次请求就+1，最为简单的算法，但这个算法有时会让通过请求量允许为限制的两倍。
- 滑动窗口计数器：通过将窗口再细分，并且按照时间“滑动”来解决突破限制的问题。不过当窗口中流量到达阈值时，流量会瞬间切断，在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。
- 漏桶：请求类似水滴，先放到桶里，服务的提供方则按照固定的速率从桶里面取出请求并执行。缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中按恒定速率等待处理
- 令牌桶：往桶里面发放令牌，每个请求过来之后拿走一个令牌，然后只处理有令牌的请求。令牌桶满了则多余的令牌会直接丢弃。令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求，因此是目前使用较为广泛的一种限流算法。
    - 令牌桶算法中有两个参数：限流速率a 、令牌桶容量b：比如 b=10，当令牌桶满的时候有10个可用令牌，此时允许10个请求同时通过限流器（允许流量一定程度的突发），这10个请求瞬间消耗完令牌后，后续的流量只能按照速率 a 通过限流器。
# 2 优缺点
- 固定窗口：临界问题，就是假设限流1000qps，在1s的前后各0.5s 有1000请求，其他时间没有请求，那就达到了2000qps
- 滑动窗口（以及固定窗口）：有突刺问题，就是假设限流1000qps，可能在100ms内有1000请求，其他900ms没有
- 漏桶和令牌桶对比时间窗口对流量的整形效果更佳，**流量更加得平滑**。
- 漏桶：
    - 请求是暂时存在桶内的。这其实不符合互联网业务低延迟的要求。
    - 即使下游某一时刻能处理更大流量，也不允许流量通过（不能处理突发流量）
- 令牌桶：如果没预热，上线时候桶里没令牌
- 漏桶和令牌桶其实比较适合阻塞式限流场景
- 基于时间窗口的限流比较适合对时间敏感的场景
# 3 代码
[请手撸5种常见限流算法！](https://www.cnblogs.com/liqiangchn/p/14253924.html)
# 4 分布式限流
[我司用了6年的Redis分布式限流器，可以说是非常厉害了](http://dockone.io/article/10137)

[分布式系统限流算法分析与实现](https://www.cnblogs.com/FG123/p/13645431.html)
- 对于rpc服务，可以通过注册中心下发单机限流值，采用单机限流
- 可以自己搭个服务，采用rpc交互。**和分布式id一样，可以一次预取一个batch，在本地限流**
- 借助redis：
    - incr方式固定窗口限流
    - lua：令牌桶限流[Redis通过lua脚本实现令牌桶](https://kang.fun/distributed-ratelimiter/)
    - redis有单机最大10w，再大不如自己搭一个