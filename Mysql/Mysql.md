<!-- TOC -->

- [1.事务属性有哪些，怎么实现的？](#1事务属性有哪些怎么实现的)
- [2.事务隔离级别有哪些，怎么实现的？](#2事务隔离级别有哪些怎么实现的)
- [3.MVCC是什么？怎么实现的？](#3mvcc是什么怎么实现的)
- [4.行锁的算法？](#4行锁的算法)
- [5.Mysql中有哪些锁？](#5mysql中有哪些锁)
- [6.两阶段锁？](#6两阶段锁)
- [7.死锁？](#7死锁)
- [8.InnoDB索引为什么采用B+树？](#8innodb索引为什么采用b树)
- [9.计算B+树能存多少条记录？](#9计算b树能存多少条记录)
- [10.索引的使用](#10索引的使用)
- [11.聚簇索引？](#11聚簇索引)
- [12.覆盖索引？](#12覆盖索引)
- [13.优化索引？](#13优化索引)

<!-- /TOC -->
# 1.事务属性有哪些，怎么实现的？
ACID
# 2.事务隔离级别有哪些，怎么实现的？
[MySQL事务隔离级别、数据一致性与加锁处理分析](https://zhuanlan.zhihu.com/p/165365896)  
- READ UNCOMMITED
    - 读不加锁
    - 写加排他锁
- READ COMMITED
    - 读使用MVCC，每次select生成快照
    - 写使用记录锁
- REPETABLE READ
    - 读使用MVCC，第一次select时生成快照
    - 写使用Next-Key locks 
    - RR隔离级别的防止幻象主要是针对写操作的，即只保证写操作的可串行化，因为只有写操作影响Binlog；而读操作是通过MVCC来保证一致性读（无幻象）。然而，可串行化隔离级别要求读写可串行化
- SERIALISABLE 
    - 读加共享锁
    - 写加排他锁
- begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。
- 解决丢失更新加锁
# 3.MVCC是什么？怎么实现的？
- 作用
减少锁的使用
- 原理
    - 在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列
        - 数据行的版本号（DB_TRX_ID）
        - 删除版本号(DB_ROLL_PT) 
    - 用法
        - SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
        - INSERT时，保存当前事务版本号为行的创建版本号
        - DELETE时，保存当前事务版本号为行的删除版本号
        - UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行
- 只在read committed和rr生效
    - 能解决幻读的**读问题**，不能解决写问题（写是当前读）
- 当前读 
    - update、delete、insert数据时都是先读后写的，MVCC在此时读数据时，只能读当前的值，而不采用上述select的方式。称为“当前读”（也由此引发丢失更新问题）
    - select语句加显式锁，也是当前读
# 4.行锁的算法？
[锁分类和行锁算法](https://juejin.im/post/6844903778026520584)  
- 行锁（Record Lock）  
锁直接加在索引记录上面。
- 间隙锁（Gap Lock）  
锁加在不存在的空闲空间，可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间。
- Next-Key Lock  
行锁与间隙锁组合起来用就叫做Next-Key Lock。  
    - 默认情况下，InnoDB工作在可重复读隔离级别下，并且以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。  
    - Next-Key Lock是行锁与间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上行锁（Record Lock），再对索引记录两边的间隙（向左扫描扫到第一个比给定参数小的值， 向右扫描扫描到第一个比给定参数大的值， 然后以此为界，构建一个区间）加上间隙锁（Gap Lock）。  
    - 如果是索引有唯一性，**降级为记录锁**
# 5.Mysql中有哪些锁？
- 全局锁  
    [全局锁](https://blog.csdn.net/zhangzhaoyuan30/article/details/88184010)  
    Flush tables with read lock(FTWRL)
- 表级锁
    - 表锁
        - lock tables ... read/write，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。
        - lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 对于InnoDB这种支持行锁的引擎，一般不使用lock tables命令来控制并发，毕竟锁住整个表的影响面还是太大。
    - MDL（Meta Data Lock）
        - 在对一个表做增删改查操作的时候，加MDL读锁；
        - 当要对表做结构变更操作的时候，加MDL写锁。
- 行锁
    共享锁
    排它锁
- 表锁
    - 意向共享  
    加共享锁前必须先取得该表的 IS 锁
    - 意向排它  
    加排他锁前必须先取得该表的 IX 锁
    - 意向锁只对普通表锁有用，对其他意向锁无效
- 加锁方法
    - 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB
会自动给涉及数据集加排他锁（X)；
    - 显式锁  
    lock in share mode、for update
- 实现方式
    - 对索引加锁
# 6.两阶段锁？
两阶段锁（two-phase locking，2PL）是数据库事务处理时的并发控制方法，以保证**可串行化**。  
- 这种方法使用数据库锁在两个阶段：    
    - 扩张阶段：不断上锁，没有锁被释放
    - 收缩阶段：锁被陆续释放，没有新的加锁（只有提交(commit)或者回滚(rollback)时才是解锁阶段）
- 2PL可能会导致死锁
    - 一次封锁法
    一次封锁法要求事务必须一次性将所有要使用的数据全部加锁，否则就不能继续执行。
- 可串行化调度
    - 如果一并行调度的结果等价于某一串行调度的结果，那么这个并行调度称为可串行化的
    - 若所有事务均遵守两段锁协议，则这些事务的所有交叉调度都是可串行化的。
# 7.死锁？
- innodb_deadlock_detect（默认开启）  
InnoDB 引擎采取的是 wait-for graph 等待图的方法来自动检测死锁，如果发现死锁会回滚undo量最少的事务
- innodb_lock_wait_timeout  
    超时默认会回滚当前语句  
    - innodb_rollback_on_timeout  
    回滚当前事务
# 8.InnoDB索引为什么采用B+树？
- [B树、B+树详解](https://www.cnblogs.com/lianzhilei/p/11250589.html)
- B+树索引能找到的只是被查找数据行所在的页，然后数据库把页读入内存，再在内存中查找
- 二叉查找树->平衡二叉树->B+树
- 什么是m阶B+树？
    - 每个节点最多可以有 m 个子节点
    - 除了根节点外，每个节点最少有 (m/2) 个子节点。如果根节点不是叶节点，则至少有 2 个子节点
    - 有k个子节点必有k个元素（区别1）
    - **所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素**
    - **所有的叶子节点都在同一层，记录只存放在叶子节点中，非叶子节点只存放关键字和指向下一个孩子节点的索引**
        - B+树的磁盘读写代价更低（区别2）：内存页中能够存放更多的key，数据存放的更加紧密，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了
        - B+树的查询效率更加稳定（区别3）：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路
    - **相邻的叶子节点之间用双向链表相连**
        - 便于**范围查找**和**遍历**（区别4）
- B+树插入
    - 如果左右兄弟节点没满先移到兄弟节点
    - 小于中间节点放左边，大于中间节点放右边
    - 中间节点放index page
- B+树删除
    - 小于填充因子合并节点
- 和B树区别
见上
# 9.计算B+树能存多少条记录？
[InnoDB一棵B+树可以存放多少行数据？](https://www.cnblogs.com/leefreeman/p/8315844.html)
- 总记录数为：根节点指针数*单个叶子节点记录行数
- 单个叶子节点（页）中的记录数=16K/1K=16(假设一行记录的数据大小为1k)
- 假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170
- 一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。
# 10.索引的使用
- 最左前缀
联合索引的最左N个字段，或字符串索引的最左M个字符
    - InnoDB 引擎单一字段索引的长度最大为 767 字节
- 匹配范围值
- 精确匹配前N列，范围匹配最后一列
- 联合索引不能跳过某一列
- 如何可以按照索引查到值，也可以按照这种方式order by 
- 哈希索引
    - 必须精确匹配索引所有列
    - 对于每一行数据，存储引擎会对所有索引列计算一个哈希码。哈希索引将哈希码存储在索引中，同时在哈希表中保存每个数据行的指针
    - InnoDB引擎支持自适应哈希索引
- 索引的优点
    - 减少服务器需要扫描的数据量
    - 避免排序和临时表
    - 将随机I/O变为顺序I/O
- 索引的选择性
    - 概念：基数/记录总数
    - select count(distinct left(city,3))/count(*) from table;
    - 缺点：无法使用前缀索引做order by 和 group by ，也无法覆盖索引
- 不使用索引的情况  
当访问的数据占整个表中数据的很大一部分（20%左右），且没有覆盖索引，优化器可能会选择通过聚簇索引查找，因为二级索引后回表导致随机IO
# 11.聚簇索引？
- 概念：数据行存在索引的叶子页中
- 通过主键聚集数据，如果没有则选择一个唯一非空索引代替
- 优点
    - 可以把相关数据保存在一起，减少磁盘IO
    - 覆盖索引可以直接使用叶节点中的主键值
- 缺点
    - 插入速度严重依赖于插入顺序
        - 如果没有需要聚集的数据可以定义一个自增主键，避免随机
    - 更新聚簇索引列的代价高。需要将行移动到新位置
    - 全表扫描慢，尤其是数据稀疏或页分裂导致数据存储不连续时
    - 二级索引大，因为叶子节点包含了主键
    - 二级索引需要两次索引查找
- 与MyISAM比较
    - 按数据插入顺序存储在磁盘
    - 二级索引存储行指针
# 12.覆盖索引？
- 索引覆盖所需查询的字段，Extra列有Using index
- 优点
    - 避免二级查询回表
    - 索引按顺序存储，对于范围查找避免随机IO
# 13.优化索引？
- INDEX HINT
    - USE INDEX
    - FORCE INDEX
- Multi-Range Read(MRR)  
减少磁盘随机访问，将随机访问转化为顺序访问。用于range、ref、eq_ref类型的查询。
    - 二级索引查询的主键进行排序，再按照主键进行书签查找
    - 减少了缓冲池中页被替换的次数  
    如果缓冲池不够大放不下一张表的数据，频繁的离散读导致缓存的页被替换出缓冲池
    - 将范围查询拆分为键值对，避免读出无用数据  
    where a > 1000 and a < 2000 and b=1000 转化为(1000,1000),(1001,1000)...
- Index Condition Pushdown(ICP)  
where过滤操作放在存储引擎层，Extra可以看到Using index condition
    - WHERE 可以过滤的条件是该索引可以覆盖到的范围
- 索引总结
    - 单行访问慢。读取的数据块尽可能包含更多行。
    - 顺序访问快。一是不需要多次寻址，二是避免额外排序
    - 覆盖查询很快