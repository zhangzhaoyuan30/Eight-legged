<!-- TOC -->

- [0 虚表](#0-虚表)
- [1 无符号数](#1-无符号数)
- [2 指针和引用](#2-指针和引用)
- [3 指针](#3-指针)
- [4 const](#4-const)
    - [4.1 指针和引用](#41-指针和引用)
    - [4.2 常量表达式](#42-常量表达式)
- [5 vector](#5-vector)
- [6 数组](#6-数组)
- [7 参数传递](#7-参数传递)
- [8 const 成员函数](#8-const-成员函数)
- [9 类类型转换](#9-类类型转换)
- [10 constexpr](#10-constexpr)
- [11 静态成员](#11-静态成员)
- [12 lambda](#12-lambda)
- [13 智能指针](#13-智能指针)
    - [13.1 sharedptr](#131-sharedptr)
    - [13.2 uniqueptr](#132-uniqueptr)
    - [13.3 weakptr](#133-weakptr)
- [14 new](#14-new)
- [15 allocator](#15-allocator)
- [16 拷贝控制](#16-拷贝控制)
    - [16.1 拷贝构造函数和拷贝赋值运算符](#161-拷贝构造函数和拷贝赋值运算符)
    - [16.2 析构函数](#162-析构函数)
    - [16.3 delete](#163-delete)
- [17 友元](#17-友元)
    - [18 对象移动和右值引用](#18-对象移动和右值引用)
- [19 运算符重载](#19-运算符重载)
- [20 面向对象](#20-面向对象)
    - [20.1 虚函数](#201-虚函数)
    - [20.2 派生访问说明符](#202-派生访问说明符)
- [21 模板](#21-模板)
- [22 命名空间](#22-命名空间)
- [23 虚继承](#23-虚继承)

<!-- /TOC -->
# 0 虚表
[C++ 虚函数表指针以及虚函数指针的确定](https://blog.csdn.net/JackZhang_123/article/details/80692420)

# 1 无符号数
表达式里既有无符号又有有符号，有符号会自动转为无符号

# 2 指针和引用
指针本身是一个对象，可以赋值和拷贝，引用不是对象，仅仅是一个别名
1. 初始化：指针可以在声明时不进行初始化，或者初始化为nullptr或空指针。**而引用必须在声明时进行初始化，并且一旦引用被初始化，就不能再引用其他对象**。
2. 空值：指针可以为空指针，表示不指向任何对象。而引用必须引用有效的对象，不能为null。
3. 语法：指针使用*和->运算符进行间接访问和成员访问。而引用在使用时与普通变量没有语法上的区别，直接使用变量名即可。
4. 重新赋值：指针可以被重新赋值，可以指向不同的对象。而引用一旦初始化后，就不能再引用其他对象，它始终指向同一个对象。
5. 空间占用：指针本身占用内存空间，而引用本身不占用额外的内存空间，它只是一个别名。

# 3 指针
- &：取地址符，或声明引用
- *：解引用符，或声明指针
- void*：存放任意对象的地址。（不能直接操作所指对象）

# 4 const
## 4.1 指针和引用
- const修饰引用，不能修改被引用的对象。引用本身本来就是不可变的。
- const修饰指针
- 指向常量的指针（底层）：和上面指向常量的引用一样（const int *a=\&b）
- 常量指针（顶层）：指针本身是常量（即指针指向的地址不可变）（int *const a=&b）
## 4.2 常量表达式
- 值不会改变并且在编译过程中就能得到计算结果的表达式
- constexpr 变量：编译器会验证变量的值是否是一个常量表达式

# 5 vector
vector是模板而不是类型，模板不是类，是生成类或函数的说明。

引用不是对象，所以vector不能存引用
# 6 数组
数组名在某种程度上类似于指针，它可以被解释为指向数组首元素的指针。

# 7 参数传递
形参是引用类型，则实参被引用传递（或者说形参绑定到实参上），其他是值传递（拷贝）

# 8 const 成员函数
当一个成员函数被声明为const时，它表明该函数不会修改对象的状态

常量对象及其引用或者指针都只能调用常量成员函数
# 9 类类型转换
隐式转换：通过构造函数的参数类型向类类型转换。可以通过explicit组织

# 10 constexpr
用于声明在编译时求值的常量表达式

# 11 静态成员
在 C++ 中，静态成员变量和静态成员函数是属于类的成员，而不是属于类的实例。静态成员变量的初始化通常**需要在类外部进行**，而不是在类的定义中。

> 完全类型（Complete Type）指的是已完全定义的类型，包括其大小、布局、成员变量和成员函数等信息都已知。只有完全类型的对象可以被创建、操作和传递。

？？？非静态成员变量在类中表示对象的一部分，它们的存在和布局依赖于类的完整定义。因此，非静态成员变量必须是完全类型，而不是不完全类型。静态成员可以是不完全类型。

# 12 lambda
捕获列表只用于局部非static变量，因为局部static变量和所在函数之外的变量可以直接使用

Lambda函数可以捕获外部变量，并且默认情况下，Lambda函数是const的，即不允许修改捕获的变量。然而，有时候我们可能希望在Lambda函数内部修改被捕获的变量，这时可以使用mutable关键字。

需要注意的是，使用mutable关键字的Lambda函数可以修改被捕获的变量的副本，但不能修改非可修改的（const）变量或通过引用捕获的变量。

# 13 智能指针
## 13.1 shared_ptr
- shared_ptr允许多个指针指向一个对象，unique_ptr独占对象，weak_ptr指向shared_ptr管理的对象
- 建议都是用智能指针，全局生命周期可以用裸指针
- 
    ```c++
    void process(std::shared_ptr<int> ptr) {
    // 没有对智能指针进行任何处理
    }

    int main() {
        int* rawPtr = new int(42);
        process(std::shared_ptr<int>(rawPtr));
        // 在这里，std::shared_ptr 对象已经被销毁，但是 rawPtr 现在成为了悬挂指针
        // 尝试访问 *rawPtr 将导致未定义行为
        return 0;
    }
    ```
- 发生异常时也能释放内存，但裸指针不会
## 13.2 unique_ptr
不支持拷贝，当unique_ptr被销毁时，其所指向的对象也销毁

## 13.3 weak_ptr
绑定到一个shared_ptr，但不参与引用计数。可以通过lock()返回一个shared_ptr

# 14 new
- 不能delete栈内存
- 在delete释放内存后，如何避免空悬指针？
    - delete之后，指针要设为nullptr
    - 避免多个指针指向同一个内存，因为即使一个设为nullptr，还有其他的

# 15 allocator
new将内存分配和对象构造放在了一起，delete将对象析构和内存释放放在了一起。使用allocator可以按需构造，可以对没有默认构造函数的类动态分配数组

# 16 拷贝控制
- 如果一个类需要一个析构函数，几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。反过来不成立
- 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反过来也成立
- 三五原则：定义了任何一个拷贝操作，就应该定义所有五个操作
## 16.1 拷贝构造函数和拷贝赋值运算符
- 合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中
- 发生时机
    - 用=定义变量
    - 将一个对象作为实参传递给一个非引用类型的形参
    - 从一个返回类型为非引用类型的函数返回一个对象
    - 用花括号初始化数组元素或一个聚合类的成员
    - 标准库容器调用insert或push（emplace是直接初始化）
## 16.2 析构函数
- 不接受参数，不能重载
- 发生时机
    - 变量在离开作用域时被销毁
    - 当一个对象被销毁时，其成员被销毁
    - 容器（标准库或数组）被销毁时，其元素被销毁
    - 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
    - 临时对象，当创建它的完整表达式结束时被销毁
- 合成的析构函数体为空，成员是在析构函数体之后隐含的析构阶段中销毁的
## 16.3 delete
如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的控制成员函数被定义为删除的

# 17 友元
被声明为友元的类或函数可以访问声明该友元的类的非公有成员

## 18 对象移动和右值引用
- 左值（Lvalue）是一个可标识并具有持久性的表达式或对象，其地址可以获取并且可以作为函数的参数、赋值操作的目标等。简而言之，左值是一个可以被取地址的、有名字的表达式或对象。例如，变量、函数返回的左值引用、对象成员等都属于左值。
- 右值（Rvalue）是一个临时的、不可寻址的表达式或对象，其值只在表达式计算期间存在，并且无法获取其地址。右值是一个临时的、没有名字的值。例如，**字面量、表达式的结果、临时对象等都属于右值**。
- 由于右值引用只能绑定到临时对象：
    - 所引用的对象将要被销毁
    - 该对象没有其他用户
    - 这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源
- 只有当一个类没有定义拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符
- 定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认被定义为删除的
- **如果既有移动构造函数，又有拷贝构造函数，移动右值，拷贝左值**
- 调用move，必须确定移动后原对象没有其他用户。在移动构造函数和移动赋值运算符之外的地方，只有确认是安全的，才可以使用move
- 引用限定符可以区分重载版本

# 19 运算符重载
当把运算符定义为成员函数时，左侧运算对象必须是运算符所属类的一个对象。且此时this绑定到左侧运算对象，显式参数比运算对象的数量少一个

# 20 面向对象
使用基类引用（或指针）调用虚函数时将发生动态绑定
基类通常应该定义一个虚析构函数，及时该函数不执行任何实际操作
## 20.1 虚函数
动态绑定机制的差异：在 Java 中，方法的调用是基于动态绑定（Dynamic Binding）机制，也称为后期绑定（Late Binding）。这意味着在运行时，根据对象的实际类型来决定调用哪个方法。而在 C++ 中，默认情况下，方法调用是基于静态绑定（Static Binding）机制，也称为早期绑定（Early Binding）。**只有在使用虚函数和指针/引用的情况下，才会进行动态绑定。**
## 20.2 派生访问说明符
只能控制派生类**用户**对于基类成员的访问权限，不能控制派生类本身对基类成员的访问权限。

class默认私有继承，struct默认公有继承

# 21 模板
- 编译器遇到模板定义时，并不生成代码，而是当实例化模板的一个特定版本时生成
- 通常类的定义和函数声明在头文件中，而普通函数及类的成员函数定义放在源文件。模板则不同，为了生成一个实例化版本，**编译器需要掌握函数模板或类模板成员函数的定义，因此模板的头文件通常既包括声明也包括定义**
- 显式实例化模板：为了避免重复实例化模板，可以通过extern在用到的地方声明，只定义（实例化）一次
- 将一个左值(int i)传递给函数的右值引用参数，且该右值引用指向模板类型参数（T&&），编译器会推断模板类型参数为int&，而非int。（从而将一个左值传给了右值参数，相当于间接创建了引用的引用）
- **std::move（将左值转换为右值）原理**

# 22 命名空间
未命名命名空间：可以在文件内不连续，但不能跨越多个文件

# 23 虚继承
使用虚继承，我们可以告诉编译器在继承链中只保留一个共享的基类子对象，从而避免数据冗余和混乱。