<!-- TOC -->

- [1. Reentranlock怎么实现？](#1-reentranlock怎么实现)
- [2. AQS原理？](#2-aqs原理)
- [3. ReentrantLock优势？](#3-reentrantlock优势)
- [4. ConcurrentHashMap原理？](#4-concurrenthashmap原理)
- [5.Hapens-Before是什么？](#5hapens-before是什么)
- [6.volatile有什么用？](#6volatile有什么用)
- [7.final如何保证初始化安全性？](#7final如何保证初始化安全性)
- [8.wait/notify](#8waitnotify)
- [9.wait和condition区别？](#9wait和condition区别)
- [10.ThreadLocal原理？](#10threadlocal原理)
- [11.阻塞队列有哪些？](#11阻塞队列有哪些)
- [12.Fork/join是什么？原理是？](#12forkjoin是什么原理是)
- [13.原子类有哪些？](#13原子类有哪些)
- [14.并发工具类了解哪些？](#14并发工具类了解哪些)
- [15.线程池用法？](#15线程池用法)

<!-- /TOC -->
# 1. Reentranlock怎么实现？
- Sync:
  - nonfairTryAcquire  
   如果stat=0，cas操作设置stat为1，设置持锁线程
   否则，如果重入则加1
   - tryRelease
   先判断是否是持锁线程，然后设置stat为getStat-1
- NonfairSync:
    - tryAcquire调用nonfairTryAcquire
- FairSync:  
    - tryAcquire    
    如果stat=0，**先判断队列中是否有其他线程等待**，如果没有cas操作设置stat为1，设置持锁线程  
    否则，如果重入则加1


# 2. AQS原理？
- 基于模板方法模式
    - 模板方法分为三类
        - 独占式获取与释放同步状态 acquire
        - 共享式获取与释放同步状态 acquireShared
        - 查询同步队列中的等待线程情况
    - 步骤
        1. 使用者需要**继承**同步器并**重写**指定的方法    
        2. 将同步器**组合**在自定义同步组件的实现中
        3. 调用同步器提供的模板方法：模板方法将会调用使用者重写的方法
    - 可重写方法  
    tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively
- acquire:

    ```
    public final void acquire(int arg) {
        //获取stat
        if (!tryAcquire(arg) &&
        //不成功则加入队列尾部
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
    }
    ```
    acquireQueued()中循环判断前驱是否头结点：
    
    - 是，tryAcquire，成功后当前节点设为头结点
    
    - 否，进入等待
- release：
    ```
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
        }
        return false;
    }
    ```
    unparkSuccessor()的作用是**唤醒当前线程的后继线程**

# 3. ReentrantLock优势？

    公平性，可超时，可中断
# 4. ConcurrentHashMap原理？  
- 参考  
    [ConcurrentHashMap原理](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ConcurrentHashMap%E6%BA%90%E7%A0%81+%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.md)  
    [JDK8原理](https://www.cnblogs.com/yangming1996/p/8031199.html)
- get不加锁
- JDK7: 包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，默认 Segment 的个数是 16 个，你也可以认为 ConcurrentHashMap 默认支持最多 16 个线程并发
    - segments数组的长度*ssize*是2的N次方，大于或等于**concurrencyLevel**的最小的2的N次方值
    - cap=initialCapacity除以ssize
    
- JDK8：
    - sizeCtl:
        - 0：默认值
        - -1：代表哈希表正在进行初始化
        - 大于0：相当于 HashMap 中的 threshold，表示阈值
        - 小于-1：代表有多个线程正在进行扩容
    - put:  
        - 如果未初始化先初始化initTable()
        - 当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入
        - 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。
        - 如果都不满足，则利用 synchronized 锁写入数据
        - 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树
        - CAS 式更新baseCount，并判断是否需要扩容
    - initTable：
        只允许一个线程对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度

    - helpTransfer；
        待补充
 
# 5.Hapens-Before是什么？
- 定义：一个操作的结果对于另一个操作可见。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法
- 包含：程序顺序、synchronized、volatile、传递性
 
# 6.volatile有什么用？
- 内存语义
    - 写：本地内存的所有共享变量刷新到主内存
    - 读：本地内存设为无效，从主内存读
- volatile建立的happens-before关系  
根据volatile原则和传递性原则

# 7.final如何保证初始化安全性？
- 两个final域规则
    - 写  
    在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
    写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了
    - 读  
    初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序
- final域为引用类型  
在构造函数内对一个final对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量
- this溢出  
    - 不能在构造函数内把this赋值给其他变量  
    - 在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值

# 8.wait/notify
- 等待/通知机制**依托于同步机制**，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改
- 经典范式
加锁、条件循环、处理逻辑
    ```
    //  等待方
    synchronized(对象) {
        while(条件不满足) {
            对象.wait();
        }
        // 对应的处理逻辑
    }
    // 通知方
    synchronized(对象) {
        改变条件
        对象.notifyAll();
    }
    ```    
- 原理
    - notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，
    - 而notifyAll()
    方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED
# 9.wait和condition区别？
- 区别
    - 支持在等待中不响应中断
    - 支持等待到将来某个时间

# 10.ThreadLocal原理？
- 每个线程持有一个ThreadLocalMap
- ThreadLocalMap的key为当前ThreadLocal
- 可以继承ThreadLocal，覆写initialValue()方法
```
public void set(T value) {
    Thread t = Thread.currentThread();
    // 每个线程持有一个ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // key为当前ThreadLocal
        map.set(this, value);
    } else {
        createMap(t, value);
    }        
}

ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    // 可以继承ThreadLocal，覆写initialValue()方法
    return setInitialValue();
}
```
# 11.阻塞队列有哪些？
- 有界
    - ArrayBlockingQueue

- 无界
    - LinkedBlockingQueue
    - PriorityBlockingQueue
    - DelayQueue  
    延时获取元素
        - 应用场景
            - 缓存系统
            - 定时任务调度
- 其他
    - SynchronousQueue
    不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。
# 12.Fork/join是什么？原理是？
```
public class ForkJoinCalculator implements Calculator {
    private ForkJoinPool pool;

    private static class SumTask extends RecursiveTask<Long> {
        private long[] numbers;
        private int from;
        private int to;

        public SumTask(long[] numbers, int from, int to) {
            this.numbers = numbers;
            this.from = from;
            this.to = to;
        }

        @Override
        protected Long compute() {
            // 当需要计算的数字小于6时，直接计算结果
            if (to - from < 6) {
                long total = 0;
                for (int i = from; i <= to; i++) {
                    total += numbers[i];
                }
                return total;
            // 否则，把任务一分为二，递归计算
            } else {
                int middle = (from + to) / 2;
                SumTask taskLeft = new SumTask(numbers, from, middle);
                SumTask taskRight = new SumTask(numbers, middle+1, to);
                taskLeft.fork();
                taskRight.fork();
                return taskLeft.join() + taskRight.join();
            }
        }
    }

    public ForkJoinCalculator() {
        // 也可以使用公用的 ForkJoinPool：
        // pool = ForkJoinPool.commonPool()
        pool = new ForkJoinPool();
    }

    @Override
    public long sumUp(long[] numbers) {
        return pool.invoke(new SumTask(numbers, 0, numbers.length-1));
    }
}
```
- 工作窃取算法
被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。
- ForkJoinTask
    - fork： 执行子任务
        - 调用ForkJoinWorkerThread的pushTask方法
异步地执行这个任务
        - pushTask方法把当前任务存放在ForkJoinTask数组队列里
        - 然后再调用ForkJoinPool的
signalWork()方法唤醒或创建一个工作线程来执行任务
    - join： 阻塞当前线程并等待获取结果
        - doJoin：如果没有执行完，则从任务数组里取出任务并执行
    - compute
        - 任务是否足够小就直接执行任务
        - 如果不足够小，就必须分割成两个子任务，join方法获取执行结果后合并
    - 实现类
        - RecursiveAction
        无返回结果
        - RecursiveTask
        有返回结果
- ForkJoinPool

# 13.原子类有哪些？
基本、数组、引用、volatile字段  
原理 unSafe类

# 14.并发工具类了解哪些？
- CountdownLatch
    - await: sync.acquireSharedInterruptibly(1)
    - countDown: sync.releaseShared(1)
- CyclicBarrier
    - await
    - reset()重置
- Semaphore
    - 控制同时访问特定资源的线程数量
    - acquire
    - release
- Exchanger
    - exchange方法交换数据  
    用于校对
# 15.线程池用法？
线程池的几个参数
见xmind
shutdown、shutdownNow